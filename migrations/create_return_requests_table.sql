-- =============================================
-- CREATE RETURN REQUESTS TABLE
-- =============================================
-- This table stores return authorization requests from customers
-- Admins can review and approve/reject returns, generating RA numbers

CREATE TABLE IF NOT EXISTS return_requests (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES users(id) ON DELETE SET NULL,
  
  -- Order Information
  order_number VARCHAR(255) NOT NULL,
  order_id UUID REFERENCES orders(id) ON DELETE SET NULL,
  
  -- Return Details
  reason TEXT NOT NULL,
  status VARCHAR(50) DEFAULT 'pending' CHECK (status IN ('pending', 'approved', 'rejected', 'processing', 'completed', 'cancelled')),
  return_authorization_number VARCHAR(50) UNIQUE, -- RA number generated by admin
  
  -- Photos/Attachments (stored as JSON array of URLs)
  photos JSONB DEFAULT '[]'::jsonb,
  
  -- Admin Notes
  admin_notes TEXT,
  rejection_reason TEXT,
  
  -- Return Address (provided in RA email)
  return_address TEXT,
  
  -- Timestamps
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
  approved_at TIMESTAMP WITH TIME ZONE,
  completed_at TIMESTAMP WITH TIME ZONE
);

-- Indexes for better query performance
CREATE INDEX IF NOT EXISTS idx_return_requests_user_id ON return_requests(user_id);
CREATE INDEX IF NOT EXISTS idx_return_requests_order_id ON return_requests(order_id);
CREATE INDEX IF NOT EXISTS idx_return_requests_order_number ON return_requests(order_number);
CREATE INDEX IF NOT EXISTS idx_return_requests_status ON return_requests(status);
CREATE INDEX IF NOT EXISTS idx_return_requests_ra_number ON return_requests(return_authorization_number);
CREATE INDEX IF NOT EXISTS idx_return_requests_created_at ON return_requests(created_at);

-- RLS (Row Level Security)
ALTER TABLE return_requests ENABLE ROW LEVEL SECURITY;

-- Users can view their own return requests
DROP POLICY IF EXISTS "Users can view their own return requests" ON return_requests;
CREATE POLICY "Users can view their own return requests" ON return_requests
  FOR SELECT USING (auth.uid() = user_id);

-- Users can create their own return requests
DROP POLICY IF EXISTS "Users can create their own return requests" ON return_requests;
CREATE POLICY "Users can create their own return requests" ON return_requests
  FOR INSERT WITH CHECK (auth.uid() = user_id);

-- Users can update their own pending return requests (to cancel)
DROP POLICY IF EXISTS "Users can update their own pending return requests" ON return_requests;
CREATE POLICY "Users can update their own pending return requests" ON return_requests
  FOR UPDATE USING (auth.uid() = user_id AND status = 'pending');

-- Admins can view all return requests
DROP POLICY IF EXISTS "Admins can view all return requests" ON return_requests;
CREATE POLICY "Admins can view all return requests" ON return_requests
  FOR SELECT USING (
    auth.uid() IN (
      SELECT id FROM users WHERE role IN ('admin', 'superadmin')
    )
  );

-- Admins can update all return requests
DROP POLICY IF EXISTS "Admins can update all return requests" ON return_requests;
CREATE POLICY "Admins can update all return requests" ON return_requests
  FOR UPDATE USING (
    auth.uid() IN (
      SELECT id FROM users WHERE role IN ('admin', 'superadmin')
    )
  );

-- Admins can delete return requests
DROP POLICY IF EXISTS "Admins can delete return requests" ON return_requests;
CREATE POLICY "Admins can delete return requests" ON return_requests
  FOR DELETE USING (
    auth.uid() IN (
      SELECT id FROM users WHERE role IN ('admin', 'superadmin')
    )
  );

-- Function to generate RA number (format: RA-YYYYMMDD-XXXXX)
CREATE OR REPLACE FUNCTION generate_ra_number()
RETURNS VARCHAR(50) AS $$
DECLARE
  ra_number VARCHAR(50);
  date_part VARCHAR(8);
  random_part VARCHAR(5);
BEGIN
  date_part := TO_CHAR(NOW(), 'YYYYMMDD');
  random_part := LPAD(FLOOR(RANDOM() * 100000)::TEXT, 5, '0');
  ra_number := 'RA-' || date_part || '-' || random_part;
  
  -- Ensure uniqueness
  WHILE EXISTS (SELECT 1 FROM return_requests WHERE return_authorization_number = ra_number) LOOP
    random_part := LPAD(FLOOR(RANDOM() * 100000)::TEXT, 5, '0');
    ra_number := 'RA-' || date_part || '-' || random_part;
  END LOOP;
  
  RETURN ra_number;
END;
$$ LANGUAGE plpgsql;

-- Add comments for documentation
COMMENT ON TABLE return_requests IS 'Stores return authorization requests from customers';
COMMENT ON COLUMN return_requests.return_authorization_number IS 'Unique RA number generated by admin when approving return (format: RA-YYYYMMDD-XXXXX)';
COMMENT ON COLUMN return_requests.photos IS 'JSON array of photo URLs uploaded by customer';
COMMENT ON COLUMN return_requests.return_address IS 'Return shipping address provided to customer in RA email';

-- Success message
DO $$
BEGIN
  RAISE NOTICE 'âœ… Return requests table created successfully!';
  RAISE NOTICE '   - Stores customer return requests';
  RAISE NOTICE '   - Admins can approve and generate RA numbers';
  RAISE NOTICE '   - Supports photo uploads';
  RAISE NOTICE '   - Ready for return management system';
END $$;

